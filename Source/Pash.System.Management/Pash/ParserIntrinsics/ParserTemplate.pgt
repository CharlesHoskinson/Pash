##TEMPLATE-NAME 'C# - Morozov Engine (.NET 1.x) - Dolan'
##LANGUAGE 'C#'
##ENGINE-NAME 'Morozov GOLD Parser Engine'
##AUTHOR 'David Dolan (Engine by Vladimir Morozov)' 
##FILE-EXTENSION 'cs'
##NOTES
This template creates the constants for symbols
and rules and a custom parser class that acts
as a template for parsing any source.

This version was created by Dave Dolan. 

The template was based on the example code provided with the Morozov Engine Source Package
available from http://www.notebar.com

##END-NOTES
##ID-CASE ProperCase
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'
///////////////////////////////////////////////////////////////////
//
// Autogenerated file. Do not edit.
//
///////////////////////////////////////////////////////////////////


using System;
using System.Reflection;
using System.IO;
using System.Text;
using System.Runtime.Serialization;
using System.Collections.Generic;

using GoldParser;

namespace Pash.ParserIntrinsics
{
    enum SymbolConstants : int
    {
##SYMBOLS
##DELIMITER ','
        %ID% = %Value%%Delimiter% // %Description%
##END-SYMBOLS
    };

    enum RuleConstants : int
    {
##RULES
##DELIMITER ','
        %ID% = %Value%%Delimiter% // %Description%
##END-RULES
    };

    public class PashParser
    {
        PashParserContext m_context;
        ASTNode m_AST;
        string m_errorString;
        Parser m_parser;

        public int LineNumber
        {
            get
            {
                return m_parser.LineNumber;
            }
        }

        public int LinePosition
        {
            get
            {
                return m_parser.LinePosition;
            }
        }

        public string ErrorString
        {
            get
            {
                return m_errorString;
            }
        }

        public string ErrorLine
        {
            get
            {
                return m_parser.LineText;
            }
        }

        public ASTNode SyntaxTree
        {
            get
            {
                return m_AST;
            }
        }

        public bool Parse(string source)
        {
            return Parse(new StringReader(source));
        }

        public bool Parse(StringReader sourceReader)
        {
            m_parser = ParserFactory.CreateParser(sourceReader);
            m_parser.TrimReductions = true;
            m_context = new PashParserContext(m_parser);

            while (true)
            {
                switch (m_parser.Parse())
                {
                    case ParseMessage.LexicalError:
                        m_errorString = string.Format("Lexical Error. Line {0}. Token {1} was not expected.", m_parser.LineNumber, m_parser.TokenText);
                        return false;

                    case ParseMessage.SyntaxError:
                        StringBuilder text = new StringBuilder();
                        foreach (Symbol tokenSymbol in m_parser.GetExpectedTokens())
                        {
                            text.Append(' ');
                            text.Append(tokenSymbol.ToString());
                        }
                        m_errorString = string.Format("Syntax Error. Line {0}. Expecting: {1}.", m_parser.LineNumber, text.ToString());

                        return false;
                    case ParseMessage.Reduction:
                        m_parser.TokenSyntaxNode = m_context.CreateASTNode();
                        break;

                    case ParseMessage.Accept:
                        m_AST = m_parser.TokenSyntaxNode as ASTNode;
                        m_errorString = null;
                        return true;

                    case ParseMessage.InternalError:
                        m_errorString = "Internal Error. Something is horribly wrong.";
                        return false;

                    case ParseMessage.NotLoadedError:
                        m_errorString = "Grammar Table is not loaded.";
                        return false;

                    case ParseMessage.CommentError:
                        m_errorString = "Comment Error. Unexpected end of input.";

                        return false;

                    case ParseMessage.CommentBlockRead:
                    case ParseMessage.CommentLineRead:
                        // don't do anything 
                        break;
                }
            }
         }

    }

    public class PashParserContext
    {

        // instance fields
        private Parser m_parser;

        private TextReader m_inputReader;



        // constructor
        public PashParserContext(Parser prser)
        {
            m_parser = prser;
        }


        private string GetTokenText()
        {
            // delete any of these that are non-terminals.

            switch (m_parser.TokenSymbol.Index)
            {

##SYMBOLS
                case (int)SymbolConstants.%ID% :
                //%Description%
                //Token Kind: %Kind%
                //todo: uncomment the next line if it's a terminal token ( if Token Kind = 1 )
                // return m_parser.TokenString;
                return null;

##END-SYMBOLS
                default:
                    throw new SymbolException("You don't want the text of a non-terminal symbol");

            }

        }

        public ASTNode CreateASTNode()
        {
            switch (m_parser.ReductionRule.Index)
            {
##RULES
                case (int)RuleConstants.%ID% :
                //%Description%
                //todo: Perhaps create an object in the AST.
                return null;

##END-RULES
                default:
                    throw new RuleException("Unknown rule: Does your CGT Match your Code Revision?");
            }

        }

    }

}

///////////////////////////////////////////////////////////////////
//
// Autogenerated file. Do not edit.
//
///////////////////////////////////////////////////////////////////

using System;
using System.IO;

using GoldParser;

namespace Pash.ParserIntrinsics
{
    using Nodes;
    
    public partial class PashParserContext
    {
        private readonly Parser m_parser;

        public PashParserContext(Parser parser)
        {
            m_parser = parser;
        }

        public string GetTokenText()
        {
            if (m_parser.TokenSymbol.SymbolType == SymbolType.Terminal) 
                return m_parser.TokenString;
            else
                return null;
        }

        public ASTNode CreateASTNode()
        {
            ASTNode node = null;
            
            switch (m_parser.ReductionRule.Index)
            {
                // Rule_Statementseparatortoken_Newline:
                //      <statementSeparatorToken> ::= NewLine <statementSeparatorToken>
                case 0: 
                    CreateNodeForRule_Statementseparatortoken_Newline(m_parser, ref node);
                    return node;

                // Rule_Statementseparatortoken:
                //      <statementSeparatorToken> ::= 
                case 1: 
                    CreateNodeForRule_Statementseparatortoken(m_parser, ref node);
                    return node;

                // Rule_Statementlistrule:
                //      <statementListRule> ::= <statementRule>
                case 2: 
                    CreateNodeForRule_Statementlistrule(m_parser, ref node);
                    return node;

                // Rule_Statementlistrule2:
                //      <statementListRule> ::= <statementRule> <statementSeparatorToken> <statementListRule>
                case 3: 
                    CreateNodeForRule_Statementlistrule2(m_parser, ref node);
                    return node;

                // Rule_Statementrule:
                //      <statementRule> ::= <pipelineRule>
                case 4: 
                    CreateNodeForRule_Statementrule(m_parser, ref node);
                    return node;

                // Rule_Statementrule_Commenttoken:
                //      <statementRule> ::= CommentToken
                case 5: 
                    CreateNodeForRule_Statementrule_Commenttoken(m_parser, ref node);
                    return node;

                // Rule_Pipelinerule:
                //      <pipelineRule> ::= <cmdletCall>
                case 6: 
                    CreateNodeForRule_Pipelinerule(m_parser, ref node);
                    return node;

                // Rule_Pipelinerule_Pipe:
                //      <pipelineRule> ::= <cmdletCall> '|' <pipelineRule>
                case 7: 
                    CreateNodeForRule_Pipelinerule_Pipe(m_parser, ref node);
                    return node;

                // Rule_Pipelinerule2:
                //      <pipelineRule> ::= <assignmentStatementRule>
                case 8: 
                    CreateNodeForRule_Pipelinerule2(m_parser, ref node);
                    return node;

                // Rule_Pipelinerule_Pipe2:
                //      <pipelineRule> ::= <assignmentStatementRule> '|' <pipelineRule>
                case 9: 
                    CreateNodeForRule_Pipelinerule_Pipe2(m_parser, ref node);
                    return node;

                // Rule_Assignmentstatementrule_Assignmentoperatortoken:
                //      <assignmentStatementRule> ::= <lvalueExpression> AssignmentOperatorToken <pipelineRule>
                case 10: 
                    CreateNodeForRule_Assignmentstatementrule_Assignmentoperatortoken(m_parser, ref node);
                    return node;

                // Rule_Lvalueexpression:
                //      <lvalueExpression> ::= <lvalue>
                case 11: 
                    CreateNodeForRule_Lvalueexpression(m_parser, ref node);
                    return node;

                // Rule_Lvalue:
                //      <lvalue> ::= <simpleLvalue>
                case 12: 
                    CreateNodeForRule_Lvalue(m_parser, ref node);
                    return node;

                // Rule_Simplelvalue_Variabletoken:
                //      <simpleLvalue> ::= VariableToken
                case 13: 
                    CreateNodeForRule_Simplelvalue_Variabletoken(m_parser, ref node);
                    return node;

                // Rule_Parameterargumenttoken:
                //      <ParameterArgumentToken> ::= <valueRule>
                case 14: 
                    CreateNodeForRule_Parameterargumenttoken(m_parser, ref node);
                    return node;

                // Rule_Parameterargumenttoken_Anywordtoken:
                //      <ParameterArgumentToken> ::= AnyWordToken
                case 15: 
                    CreateNodeForRule_Parameterargumenttoken_Anywordtoken(m_parser, ref node);
                    return node;

                // Rule_Parameterargumenttoken_Parametertoken:
                //      <ParameterArgumentToken> ::= ParameterToken
                case 16: 
                    CreateNodeForRule_Parameterargumenttoken_Parametertoken(m_parser, ref node);
                    return node;

                // Rule_Cmletparamslist:
                //      <cmletParamsList> ::= <ParameterArgumentToken> <cmletParamsList>
                case 17: 
                    CreateNodeForRule_Cmletparamslist(m_parser, ref node);
                    return node;

                // Rule_Cmletparamslist2:
                //      <cmletParamsList> ::= <ParameterArgumentToken>
                case 18: 
                    CreateNodeForRule_Cmletparamslist2(m_parser, ref node);
                    return node;

                // Rule_Cmdletname_Anywordtoken:
                //      <cmdletName> ::= AnyWordToken
                case 19: 
                    CreateNodeForRule_Cmdletname_Anywordtoken(m_parser, ref node);
                    return node;

                // Rule_Cmdletcall_Execcall:
                //      <cmdletCall> ::= ExecCall <cmdletName> <cmletParamsList>
                case 20: 
                    CreateNodeForRule_Cmdletcall_Execcall(m_parser, ref node);
                    return node;

                // Rule_Cmdletcall_Execcall2:
                //      <cmdletCall> ::= ExecCall <cmdletName>
                case 21: 
                    CreateNodeForRule_Cmdletcall_Execcall2(m_parser, ref node);
                    return node;

                // Rule_Cmdletcall:
                //      <cmdletCall> ::= <cmdletName> <cmletParamsList>
                case 22: 
                    CreateNodeForRule_Cmdletcall(m_parser, ref node);
                    return node;

                // Rule_Cmdletcall2:
                //      <cmdletCall> ::= <cmdletName>
                case 23: 
                    CreateNodeForRule_Cmdletcall2(m_parser, ref node);
                    return node;

                // Rule_Cmdletcall3:
                //      <cmdletCall> ::= <expressionRule>
                case 24: 
                    CreateNodeForRule_Cmdletcall3(m_parser, ref node);
                    return node;

                // Rule_Expressionrule:
                //      <expressionRule> ::= <logicalExpressionRule>
                case 25: 
                    CreateNodeForRule_Expressionrule(m_parser, ref node);
                    return node;

                // Rule_Logicalexpressionrule:
                //      <logicalExpressionRule> ::= <bitwiseExpressionRule>
                case 26: 
                    CreateNodeForRule_Logicalexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Bitwiseexpressionrule:
                //      <bitwiseExpressionRule> ::= <comparisonExpressionRule>
                case 27: 
                    CreateNodeForRule_Bitwiseexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Comparisonexpressionrule:
                //      <comparisonExpressionRule> ::= <addExpressionRule>
                case 28: 
                    CreateNodeForRule_Comparisonexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Addexpressionrule:
                //      <addExpressionRule> ::= <multiplyExpressionRule>
                case 29: 
                    CreateNodeForRule_Addexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Addexpressionrule_Additionoperatortoken:
                //      <addExpressionRule> ::= <multiplyExpressionRule> AdditionOperatorToken <addExpressionRule>
                case 30: 
                    CreateNodeForRule_Addexpressionrule_Additionoperatortoken(m_parser, ref node);
                    return node;

                // Rule_Multiplyexpressionrule:
                //      <multiplyExpressionRule> ::= <formatExpressionRule>
                case 31: 
                    CreateNodeForRule_Multiplyexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Formatexpressionrule:
                //      <formatExpressionRule> ::= <rangeExpressionRule>
                case 32: 
                    CreateNodeForRule_Formatexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Rangeexpressionrule:
                //      <rangeExpressionRule> ::= <arrayLiteralRule>
                case 33: 
                    CreateNodeForRule_Rangeexpressionrule(m_parser, ref node);
                    return node;

                // Rule_Rangeexpressionrule_Rangeoperatortoken:
                //      <rangeExpressionRule> ::= <arrayLiteralRule> RangeOperatorToken <rangeExpressionRule>
                case 34: 
                    CreateNodeForRule_Rangeexpressionrule_Rangeoperatortoken(m_parser, ref node);
                    return node;

                // Rule_Arrayliteralrule:
                //      <arrayLiteralRule> ::= <postfixOperatorRule>
                case 35: 
                    CreateNodeForRule_Arrayliteralrule(m_parser, ref node);
                    return node;

                // Rule_Arrayliteralrule_Commatoken:
                //      <arrayLiteralRule> ::= <postfixOperatorRule> CommaToken <arrayLiteralRule>
                case 36: 
                    CreateNodeForRule_Arrayliteralrule_Commatoken(m_parser, ref node);
                    return node;

                // Rule_Postfixoperatorrule:
                //      <postfixOperatorRule> ::= <propertyOrArrayReferenceRule>
                case 37: 
                    CreateNodeForRule_Postfixoperatorrule(m_parser, ref node);
                    return node;

                // Rule_Propertyorarrayreferencerule:
                //      <propertyOrArrayReferenceRule> ::= <valueRule>
                case 38: 
                    CreateNodeForRule_Propertyorarrayreferencerule(m_parser, ref node);
                    return node;

                // Rule_Valuerule_Stringtoken:
                //      <valueRule> ::= StringToken
                case 39: 
                    CreateNodeForRule_Valuerule_Stringtoken(m_parser, ref node);
                    return node;

                // Rule_Valuerule_Variabletoken:
                //      <valueRule> ::= VariableToken
                case 40: 
                    CreateNodeForRule_Valuerule_Variabletoken(m_parser, ref node);
                    return node;

                // Rule_Valuerule_Numbertoken:
                //      <valueRule> ::= NumberToken
                case 41: 
                    CreateNodeForRule_Valuerule_Numbertoken(m_parser, ref node);
                    return node;

                // Rule_Valuerule_Dollarlparan_Rparan:
                //      <valueRule> ::= '$(' <statementRule> ')'
                case 42: 
                    CreateNodeForRule_Valuerule_Dollarlparan_Rparan(m_parser, ref node);
                    return node;

                // Rule_Valuerule_Lparan_Rparan:
                //      <valueRule> ::= '(' <assignmentStatementRule> ')'
                case 43: 
                    CreateNodeForRule_Valuerule_Lparan_Rparan(m_parser, ref node);
                    return node;

                default:
                    throw new RuleException("Unknown rule: Does your CGT Match your Code Revision?");
            }
        }

        
        #region CreateASTNode Dispatch hooks
        // <statementSeparatorToken> ::= NewLine <statementSeparatorToken>
        partial void CreateNodeForRule_Statementseparatortoken_Newline(Parser parser, ref ASTNode node);
        // <statementSeparatorToken> ::= 
        partial void CreateNodeForRule_Statementseparatortoken(Parser parser, ref ASTNode node);
        // <statementListRule> ::= <statementRule>
        partial void CreateNodeForRule_Statementlistrule(Parser parser, ref ASTNode node);
        // <statementListRule> ::= <statementRule> <statementSeparatorToken> <statementListRule>
        partial void CreateNodeForRule_Statementlistrule2(Parser parser, ref ASTNode node);
        // <statementRule> ::= <pipelineRule>
        partial void CreateNodeForRule_Statementrule(Parser parser, ref ASTNode node);
        // <statementRule> ::= CommentToken
        partial void CreateNodeForRule_Statementrule_Commenttoken(Parser parser, ref ASTNode node);
        // <pipelineRule> ::= <cmdletCall>
        partial void CreateNodeForRule_Pipelinerule(Parser parser, ref ASTNode node);
        // <pipelineRule> ::= <cmdletCall> '|' <pipelineRule>
        partial void CreateNodeForRule_Pipelinerule_Pipe(Parser parser, ref ASTNode node);
        // <pipelineRule> ::= <assignmentStatementRule>
        partial void CreateNodeForRule_Pipelinerule2(Parser parser, ref ASTNode node);
        // <pipelineRule> ::= <assignmentStatementRule> '|' <pipelineRule>
        partial void CreateNodeForRule_Pipelinerule_Pipe2(Parser parser, ref ASTNode node);
        // <assignmentStatementRule> ::= <lvalueExpression> AssignmentOperatorToken <pipelineRule>
        partial void CreateNodeForRule_Assignmentstatementrule_Assignmentoperatortoken(Parser parser, ref ASTNode node);
        // <lvalueExpression> ::= <lvalue>
        partial void CreateNodeForRule_Lvalueexpression(Parser parser, ref ASTNode node);
        // <lvalue> ::= <simpleLvalue>
        partial void CreateNodeForRule_Lvalue(Parser parser, ref ASTNode node);
        // <simpleLvalue> ::= VariableToken
        partial void CreateNodeForRule_Simplelvalue_Variabletoken(Parser parser, ref ASTNode node);
        // <ParameterArgumentToken> ::= <valueRule>
        partial void CreateNodeForRule_Parameterargumenttoken(Parser parser, ref ASTNode node);
        // <ParameterArgumentToken> ::= AnyWordToken
        partial void CreateNodeForRule_Parameterargumenttoken_Anywordtoken(Parser parser, ref ASTNode node);
        // <ParameterArgumentToken> ::= ParameterToken
        partial void CreateNodeForRule_Parameterargumenttoken_Parametertoken(Parser parser, ref ASTNode node);
        // <cmletParamsList> ::= <ParameterArgumentToken> <cmletParamsList>
        partial void CreateNodeForRule_Cmletparamslist(Parser parser, ref ASTNode node);
        // <cmletParamsList> ::= <ParameterArgumentToken>
        partial void CreateNodeForRule_Cmletparamslist2(Parser parser, ref ASTNode node);
        // <cmdletName> ::= AnyWordToken
        partial void CreateNodeForRule_Cmdletname_Anywordtoken(Parser parser, ref ASTNode node);
        // <cmdletCall> ::= ExecCall <cmdletName> <cmletParamsList>
        partial void CreateNodeForRule_Cmdletcall_Execcall(Parser parser, ref ASTNode node);
        // <cmdletCall> ::= ExecCall <cmdletName>
        partial void CreateNodeForRule_Cmdletcall_Execcall2(Parser parser, ref ASTNode node);
        // <cmdletCall> ::= <cmdletName> <cmletParamsList>
        partial void CreateNodeForRule_Cmdletcall(Parser parser, ref ASTNode node);
        // <cmdletCall> ::= <cmdletName>
        partial void CreateNodeForRule_Cmdletcall2(Parser parser, ref ASTNode node);
        // <cmdletCall> ::= <expressionRule>
        partial void CreateNodeForRule_Cmdletcall3(Parser parser, ref ASTNode node);
        // <expressionRule> ::= <logicalExpressionRule>
        partial void CreateNodeForRule_Expressionrule(Parser parser, ref ASTNode node);
        // <logicalExpressionRule> ::= <bitwiseExpressionRule>
        partial void CreateNodeForRule_Logicalexpressionrule(Parser parser, ref ASTNode node);
        // <bitwiseExpressionRule> ::= <comparisonExpressionRule>
        partial void CreateNodeForRule_Bitwiseexpressionrule(Parser parser, ref ASTNode node);
        // <comparisonExpressionRule> ::= <addExpressionRule>
        partial void CreateNodeForRule_Comparisonexpressionrule(Parser parser, ref ASTNode node);
        // <addExpressionRule> ::= <multiplyExpressionRule>
        partial void CreateNodeForRule_Addexpressionrule(Parser parser, ref ASTNode node);
        // <addExpressionRule> ::= <multiplyExpressionRule> AdditionOperatorToken <addExpressionRule>
        partial void CreateNodeForRule_Addexpressionrule_Additionoperatortoken(Parser parser, ref ASTNode node);
        // <multiplyExpressionRule> ::= <formatExpressionRule>
        partial void CreateNodeForRule_Multiplyexpressionrule(Parser parser, ref ASTNode node);
        // <formatExpressionRule> ::= <rangeExpressionRule>
        partial void CreateNodeForRule_Formatexpressionrule(Parser parser, ref ASTNode node);
        // <rangeExpressionRule> ::= <arrayLiteralRule>
        partial void CreateNodeForRule_Rangeexpressionrule(Parser parser, ref ASTNode node);
        // <rangeExpressionRule> ::= <arrayLiteralRule> RangeOperatorToken <rangeExpressionRule>
        partial void CreateNodeForRule_Rangeexpressionrule_Rangeoperatortoken(Parser parser, ref ASTNode node);
        // <arrayLiteralRule> ::= <postfixOperatorRule>
        partial void CreateNodeForRule_Arrayliteralrule(Parser parser, ref ASTNode node);
        // <arrayLiteralRule> ::= <postfixOperatorRule> CommaToken <arrayLiteralRule>
        partial void CreateNodeForRule_Arrayliteralrule_Commatoken(Parser parser, ref ASTNode node);
        // <postfixOperatorRule> ::= <propertyOrArrayReferenceRule>
        partial void CreateNodeForRule_Postfixoperatorrule(Parser parser, ref ASTNode node);
        // <propertyOrArrayReferenceRule> ::= <valueRule>
        partial void CreateNodeForRule_Propertyorarrayreferencerule(Parser parser, ref ASTNode node);
        // <valueRule> ::= StringToken
        partial void CreateNodeForRule_Valuerule_Stringtoken(Parser parser, ref ASTNode node);
        // <valueRule> ::= VariableToken
        partial void CreateNodeForRule_Valuerule_Variabletoken(Parser parser, ref ASTNode node);
        // <valueRule> ::= NumberToken
        partial void CreateNodeForRule_Valuerule_Numbertoken(Parser parser, ref ASTNode node);
        // <valueRule> ::= '$(' <statementRule> ')'
        partial void CreateNodeForRule_Valuerule_Dollarlparan_Rparan(Parser parser, ref ASTNode node);
        // <valueRule> ::= '(' <assignmentStatementRule> ')'
        partial void CreateNodeForRule_Valuerule_Lparan_Rparan(Parser parser, ref ASTNode node);
        #endregion


    }
}
